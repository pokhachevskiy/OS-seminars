exclp (char* file, char* argv[], charg *argv1, ... , NULL)
execvp(char* file, char* argv[]) //argv[] -  вектор
execl (/*не ищем по пути, */ )//как execl)

execve(char* file, char* argv[], char* env[])

#include <sys/types.h> 
#include <fcntl.h>

int open(char* filename, int flag, ) >= 0 - good - дескриптор
<0 - error

int open(char* filename, int flag, mode_t mode)
O_EXCL | any
O_CREAT | any
O_WRONLY
O_RDONLY
O_RDWR

int close(int fd) fd - descriptor -  обязательно проверять ответ!!!
//unlink
0 - good, <0 - error

int read(int fd, void* address, size_t nbytes)
int write(int fd, void* address, size_t nbytes)
<0 - error, >=0  сколько прочитано/записано

umask
mode & (~umask)
umask new_mask

#include <sys/stat.h> int umask(int new_mask)

#include <unistd.h>
int pipe(int* fd)
2 descriptor если норм отработал
0 - ok, <0 - ошибка

int fd[2]
... pipe(fd)
fd[0] - чтение
fd[1] - запись
close!!

read, write - работают

живет, пока дескриптор открыт у кого либо из близкородственных


read
m - есть в pipe
n - хотим прочитать 

1. n <= m -> return n
2. m != 0, n > m -> return m - есть баг в ядре линукс
3. m = 0 -> wait(есть записывающий процесс) -> (1,2)
4. m = 0, записывать не хочу -> return 0

write
m - пустое место в pipe
n - хотим записывать
L - размер буфера

1. некому читать SIGPIPE прекращение работы
2. n <= m -> return n
3. m < n <= L -> wait(ждет пока место освободится) -> return n
4. n > L -> {wait(пока место освободится ) } -> return n

#include <unistd.h>
#include <fcntl.h>

fcntl - работает с потоками.
fcntl(int fd, int cmd, int params)
return 0 - ok
return < 0 - error
cmd F_SETFL
params O_NONBLOCK

read 
m - есть в pipe
n - хотим прочитать

1. n <= m -> return n
2. n > m != 0 -> return m
3. m = 0 -> return < 0 в errno = EAGAIN
есть записывающие процессы

4. m = 0  - некому записывать -> return 0

write
m - пустое место в буфере
n - хотим записывать
L - размер буфера

1. n <= m -> return n
2. m < n <= L -> return < 0 в errno = EAGAIN
3. n > L, m = 0 -> 2.
4. n > L, m > 0 -> return m



FIFO - именованный pipe
файл типа  FIFO

#include <sys/stat.h>
#include <unistd.h>
int mknod(char* filename, int mode, int dev = 0) //создаем файл обязательно
mode - 0666|S_IFIFO
return 0 - ok, < 0 - error

возможно есть еще одна:
int mkfifo(char* filename, mode_t mode)
mode = 0666


недостатки

1. потоковость
2. время жизни = время общения
3. 

system V IPC
 a. shared memory
 b. semaphores
 c. message queues

key_t - положительное целое
#include <sys/types.h>
#include <sys/ipc.h>

int ftok (char* filename, char nreal); <0 - error; key - >= 0
ipcd дескриптор - для связи

shmget - созадть/получить доступ к shared memory
shmat - присоединить разделяемую память к процессу
в конце требуется отсоединить память
shmdt - отсоединить раз память от нашего процесса

#include <sys/shm.h>

int shmget(key_t key, size_t nbytes, int flags) <0 - error, >= ipcd.
flags: права пользователей на доступ в случае создания 0666 | IPC_CREAT | IPC_EXCL - если существует, будет ошибка. Эксклюзив
замеч: 
1. инициализация 0 или нет //лучше делать самостоятельно

проверка на существование: shmget(IPC_EXCL) если успех, то инициализация. Иначе 
проверяем код ошибки в errno (errno.h) errno == EEXIST -> память уже создана -> shmget с 0 флагами
иначе прекратить работу -1

если мне нужна писос Эксклюзивная память (private)
int shmget(IPC_PRIVATE, size, 0666 ) return - аналогично
далее работа по дескриптору, больше  shmget не нужен

2. парметр nbytes <= размер при создании

void* shmat (int shmid, void* addr = NULL, int flags ) //shmid - дескриптор 
return (void*)(-1) - error, иначе память
flags = 0 - режим read/write
	SHM_RDONLY - только чтение

int shmdt (void* begaddr)
0 - OK, < 0 - error

shmctl
ipcs
ipcrm -> read man  

task:
A - заводим shm   (5000 байт)
открываем файл со своим исходным текстом - читаем от туда open 
и кладем в shm
завершаем работу

B - доступается к shm и печатает содержимое 


Дейкстра предложил механизм синхронизации shm 
сделаны дейстровские семафоры  
int s - разделяемая переменная,int >= 0

init(s, n) n >= 0 //иниц семафора
p(s): // от слова proberen - проверка, проба
{is (s == 0) -> wait 
s -= 1;}

v(s): s + 1//verhogen - увеличение

выполняются атомарно. Никто не может прервать их во время их действия

init(L,1)
p(L)
critical section 
V(L)

итого, в критической секции только один процесс

мы работаем с другими семафорами.
1. не один, а массив семафоров. Все семафоры обязательно инициализация нулем.
2. 
   a. d(s, n) n > 0: if (s < n) -> wait; s -= n; d(s,1) ~ P(s)//Daextra
   b. A(s, n) : s += n; A(s,1) ~ v(s)
   c. Z(s) :    if (s != 0) -> wait
3. несколько операций над семафорами из одного массива атомарно одновременно
4. есть верхняя граница

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(key_t key, int numberOfSemafors, int flags) flags 0666|IPC_CREAT|IPC_EXCL
<0 error, >= - semid

int semop (int semid, struct sembuf *buf, int nelem)
<0 error, 0 - ok

struct sembuf 
{
	int sem_num;
	int sem_op: Z -> 0; A -> n; D -> -n;
	int sem_flg: 0;
}
D(0, 1) &&
A(3, 1) &&


struct sembuf a[2];
a[0].sem_num = 0;
 --- sem_op = -1;
  	 sem_flg = 0;
a[1].sem_num = 3;
	 sem_op  = 1;
	 sem_flg = 0;

semop(semid, a, 2);


task: 
программа создает pipe, только один. Далее,fork. 
p: пишет чайлду через пайп
c: читает
c: пишет черз тот же пайп
p: читает 

это надо повторить n раз n >= 2

ненужные семафоры вовремя удалять из системы. ipcs 
простое: 2 семафоры
сложное: 1 семафор
///////////////


катер -> выходит из гавани, далее кольцевая экск -> обратно и по кругу
N - пассажиров
по трапу 1 пассажир в одно направление
сначала все выйдут, потом начинают заходить новые
while(1)  /// k = 3  3 раза плавает пассажир
{
	загрузка;
	прогулка;
	выгрузка
}
пока все места не заняты, мы не поедем
----
пассажир приходит на причал
садится на катер
-----
выходит из катера

1 процесс для катера
на каждого пассажира  по процессу 
1. не воникло тупиковой ситуации: пассажиры толпятся перед пустым катером
2. массовые самоубисйства -
3. 1 вышел, на встречу толпа, остальные выйти не успевают


2 программы
1. отвечает за работу катера
2. с помощью форков генерит пассажиров (много) (3*N пассажиров)
N > 3  - 

2 или 3 семафора - без разницы
никакой общей памяти

//канальные средства связи
send (name, msg) 
 - атомарная запись сообщения в очередь
в случае заполнения - процесс переходит в ожидание
receive (name, msg)
 - атомарность доступа к буферу хранения сообщений
 в случае отсутствия сообщений блокируется
 FIFO 

//расширение
каждое сообщение имеет атрибут - тип сообщения = type > 0, int 
сможем изменить политику выбора -> 3 разных политики
1. FIFO не зависимо от типа , 	type = 0
2. FIFO для определенного типа, type = n
3. выборка с порогом , 			type = -n
3: мы задаем пороговый тип сообщений - целое число > 0. Согласны принимать сообщения с таким порогом. Будем просматривать все сообщения 
и доставать минимальный тип не превыщающий порог. Далее, ищем новый тип не превыщающий порог. Так, пока не останутся сообщения 
только превыщающие порог.


key_t name - например ftok() 32bit
send(ipc_id name, msg)

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

//создать новую/доступиться по ключу
key - можно из ftok
 msgget(key_t key, int flags) -> int 
 return ipcd //дескриптор для очереди сообщений
flags: IPC_CREAT, IPC_EXCL, 0666 
//если очередь точно существует, то флаги не влияют
шаблон!
struct msgbuf
{
	long mtypes;
	char mtext[1]; 
	во втором пункте может стоять все что угодно
}

пример
struct mybuf 
{
	long type; 
	char text[81]; <- длина, которую мы передаем в msgsnd() //может быть нулевым
}



msgsnd(int msgid, struct msgbuf *addr, int length, int flags = 0) 
msgrcv(int msgid, struct msgbuf *addr, int maxlen, int type, int flags = 0) type - тип политики
return < 0 - error, > 0 - длина полезной части

ipcs 
ipcrm msg id

int msgctl (int msgid, int cmd = IPC_RMID, struct msq_id_ts *buf = NULL) - удаляет очередь сообщений
0 - ok, < 0 - error

задача!

struct mymsg
{
	long type;
	double i;
}

struct mymsg
{
	long type;
	struct a
	{
		char c[1];
		int i;
		double d;
	} a;
} полезная часть:  09 folder


5 сообщений с одним типом - отпр и считывать
нельзя использовать ласт message
т.к. придется читать самому



клиентов много
1. эпизодическая работа
2. иниц. связь
3. apriory значения

серевер один
1. работает постоянно
2. связь не иниц.
3. apriory значений нет

процесс сервер 
толпа клиентов 
очередь сообщений - одна 
утвердить тип сообщений = 1 читается только сервером
обрабатывает инфу и отвечает правильному клиенту 
в состав сообщений добавляется тип = pid 
клиенты ждут сообщений с типом pid 

аккуратное завершение: политика выборки - выборка с порогом - с типом 1,2
тип 1,2 - вполне безопасны
1 - все хорошо, обрабатываем и посылаем ответ
2 - завершаемся 

killer - еще один клиент, отправляющий сообщение с типом 2 




 реализация семафоров.
 p1, ... , pn - несколько процессов, которые для реш задачи должны работать через семафоры
 уметь создавать некий аналог семафоов и выпонять его инициализацию - любым целым неотр значением

 1. init( s, n)
 2. P(s) {
 	s == 0? wait;
 	s -= 1;
 }
 3. V(s) {
 	s += 1;
 }
проверка до форка!!!


очередь FIFO 
несколько переменных s  и несколько очередей сообщений соответственно.

когда мы захотим работать с нашей библиотечкой - нужен будет отдельный процесс - координатор p0
все остальные будут играть роль клиентов сервера 

координатор - хранитель переменной s 
создать очередь процессов ждущих наступления семафора ? 
иниц: если коорд еще не запущен, то нужно его стартовать и занести в переменную s = n; 
init = start p0 (если нужно ) и s = n; 
когда стартует процесс координатор - он создает пустой файл эксклюзивно, чтоб все видели этот файл, озн начало работы
всегда существует директория /tmp - пусть создает переменную там. 


p(s) - передача сообщения в очередь сообщений, в сообщ должно быть указано что это именно операция p ( с помощью типа )
p(s) - запрос серверу с типом p() и ждем ответа 

p0 в цикле ждет сообщения. Если это тип p - (s > 0 )? s -= 1, send разрешение работать дальше 
: в очередь заносим идентификатор процесса никаких подтверждений не послыаем.

v(s) - сразу послыаем подтверждение процессу, который прислал. - смотрим на очередь. 
очередь пуста? тогда s += 1 : иначе послыаем подтверждение одному ждущему процессу 


проверять будем на задачке про "медведей и пчел "

бочка меда
пчелы приносит 
последняя пчела будит медведя 
и он хавает

2 семафора 

semafore lock = 1;
		 eat = 0 ;

shared int  count = 0; 
N = 6;


пчела: bee - 4 штуки
каждая по 3 раза
while ( 1) {
	P(lock);
	count += 1;
	if (count  == N) 
		V(eat);
	else 
		v(lock);
}

медведь: bear
2 раза просыпается
while (1) {
	P(eat);
	count = 0;
	V (lock);
}



процесс послылает сообщение координатору, чтоб тот удалил свой файл -  killer  + 5 баллов







threads
#include <pthread.h>
pthread_t pthread_self(void) // return thread id
gcc ddasf -o kek -lpthread


создание 
int pthread_create(pthread_t *thid, pthread_attr_t *addr = NULL, (void *)(*func)(void *), void *args): 0 - ok, > 0 - error code

зваершение 
1. return из ассоц. функции
2. void pthread_exit(void* status);
3. главный thread завершился - остальные убиты


ожидание
int pthread_join(pthread_t thid, void** status): 0 - ok, > 0 - error code

void* myt (void *arg) {

}

число пи
площадь четверти круга с радиусом 2
методом трапеций 
довольно большое количество точек 
куча тредов
разделим примерно на 4 части 
и каждый тред считает частичную сумму в своей области
главный суммирует все и выводит число 
число точек - 100 000 
при запуске передаем сколько зон, от 1 до 10 
потребуется параметр каждому среду
получать частичную сумму 

взаимоисключение! для атомарности +-
тоже и для тредов, взаимоисключение для доступа к общим данным
если требуется порядок доступа, нам приходилось ввоодить доп вещи, связанные с синхронизацией
в тредах это 2 механизма: mutex
для проверки условий: условные переменные (близко к мониторам хора)


1. Mutex - mutual exclusion - взаимоисключение
некоторый объект, который вводится в posix тредах. Внутреннее устройство может меняться в зависимсоти от реализации.
существуют способы работы, они прописаны в стандарте posix.
описываются: 
pthread_mutex_t m1 = PHTREAD_MUTEX_INITIALIZER;// его можно захватывать и освобождать
 //m1 будет недостаточно, т.к. мы не знаем доп вызовы для работы с тредами. Можно посомтреть с pthread_mutex_init и т.д.
если некоторый поток захватил и удерживает мутех, другой поток при попытке захватить будет ждать, пока первый его освободит
похоже на семафоры Daextra в некоторой степени
освободить мутех может только захвативший поток. При попытке сделать это из другого потока будет ошибка. в этом отличие от семафоров

Захват mutex: 
int pthread_mutex_lock(pthread_mutex_t *mutex): return 0 - ok, > 0 - error code
первый проходит нормально и не блокируется, он записывается что он захватил
другой процесс заблокируется, пока не откроется. Когда откроется - продолжит работать только один тред.

при повторной попытке захватить mutex процесс заблокируется и прога гг

int pthread_mutex_unlock (pthread_mutex_t *mutex) // открытие 

условные переменные
есть wait и signal
если применяю wait, то процесс принудительно переходит в состояние ожидания
если применяю signal, и кто-то ждал, то один из них разблокируется


pthread_cond_t c1 = PHTREAD_COND_INITIALIZER;

пример: if (smth) c1.wait; 
пока кто-нибудь c1.signal 
неприятности: wait выполняется атомарно. Но между проверкой условия и wait есть промежуток, поэтому кто-то может поменять smth.
это некрасиво. 
Нужно ввести некоторый mutex и сделать так, чтоб mutex блокировал в условии 
Как будет остальные жить? mutex то захвачен. 
wait(c1, mutex) - он атомарно разлочит мутех

int pthread_cond_wait(pthread_cond_t *condv, pthread_mutex_t *mutex); ждем пока будет signal на condv
что будет в случае прихода signal - я пытаюсь захватить указанный mutex, если нет - жду пока освободится. 
Потом я его захватываю, и только потом я из wait выйду.

int pthread_cond_signal(pthread_cond_t *condv); //только один тред разблокирует

int pthread_cond_broadcast (pthread_cond_t *condv); // разблокируем всех ждущих !!

//example//
mutex m;
cond c;

mutex_lock(&m);
if (N == 10) 
{
	cond_wait(&c, &m);
	...
}
mutex_unlock(&m);

while (N == 10) //здесь всегда обычно while
	cond_wait(&c, &m); //можно вывалиться не только из-за signal. А потому что процесс получил другой сигнал.




задачка про пчел и медведя

главный thread - bear 
4 bee - побочные threads

N = 6; - вместимость бочки 
медведь есть 2 бочки, каждая пчела 3 раза. 


2 семафора 

semafore mutex = 1;
		 bear = 0 ;

shared int  count = 0; 
N = 6;


пчела: bee - 4 штуки
каждая по 3 раза
while ( 1) {
	P(mutex);
	count += 1;
	if (count  == N) 
		V(bear);
	else 
		v(mutex);
}

медведь: bear
2 раза просыпается
while (1) {
	P(bear);
	count = 0;
	V (mutex);
}

породил 4 треда, а main - это медведь
никакие параметры треду передавать не нужно





